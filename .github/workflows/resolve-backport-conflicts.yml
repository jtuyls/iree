name: Resolve Backport Conflicts

on:
  # Trigger when Mergify labels a PR with conflicts
  pull_request:
    types: [labeled, opened, synchronize]
  
  # Also allow manual trigger via comment
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write

jobs:
  resolve-conflicts:
    # Trigger on 'needs-ai-resolution' label or '/resolve-conflicts' comment
    if: |
      (github.event_name == 'pull_request' &&
        github.event.label.name == 'needs-ai-resolution') ||
      (github.event_name == 'issue_comment' &&
        github.event.issue.pull_request != null &&
        contains(github.event.comment.body, '/resolve-conflicts'))
    
    runs-on: ubuntu-latest
    
    steps:
      - name: Get PR info
        id: pr
        run: |
          if [ "${{ github.event_name }}" == "issue_comment" ]; then
            PR_NUMBER=${{ github.event.issue.number }}
          else
            PR_NUMBER=${{ github.event.pull_request.number }}
          fi
          echo "number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          # Get PR details
          gh pr view $PR_NUMBER --repo ${{ github.repository }} --json headRefName,baseRefName,title,body > pr_info.json
          
          HEAD_BRANCH=$(jq -r '.headRefName' pr_info.json)
          BASE_BRANCH=$(jq -r '.baseRefName' pr_info.json)
          
          echo "head_branch=$HEAD_BRANCH" >> $GITHUB_OUTPUT
          echo "base_branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
          
          # Extract original PR number from backport title like "[Backport release-1.0] Fix bug #123"
          TITLE=$(jq -r '.title' pr_info.json)
          ORIGINAL_PR=$(echo "$TITLE" | grep -oP '#\d+' | head -1 | tr -d '#')
          echo "original_pr=$ORIGINAL_PR" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ steps.pr.outputs.head_branch }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install anthropic

      - name: Identify conflicts
        id: conflicts
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Fetch all branches
          git fetch origin ${{ steps.pr.outputs.base_branch }}
          
          # Check for conflict markers in committed files (Mergify commits them)
          echo "Searching for conflict markers in committed files..."
          if git grep -l "^<<<<<<< " HEAD 2>/dev/null | sed 's/^HEAD://' > conflicting_files.txt; then
            echo "Conflicts detected in committed files"
            echo "has_conflicts=true" >> $GITHUB_OUTPUT
            cat conflicting_files.txt
          else
            echo "No conflict markers found in committed files"
            echo "has_conflicts=false" >> $GITHUB_OUTPUT
          fi

      - name: Resolve conflicts with AI
        if: steps.conflicts.outputs.has_conflicts == 'true'
        run: |
          python << 'EOF'
          import anthropic
          import subprocess
          import os
          import json

          client = anthropic.Anthropic(api_key=os.environ['ANTHROPIC_API_KEY'])

          # Read conflicting files
          with open('conflicting_files.txt') as f:
              conflicting_files = [line.strip() for line in f if line.strip()]

          print(f"Resolving conflicts in {len(conflicting_files)} files...")

          base_branch = os.environ['BASE_BRANCH']
          head_branch = os.environ['HEAD_BRANCH']
          original_pr = os.environ.get('ORIGINAL_PR', '')

          import re
          
          def extract_conflicts(content):
              """Extract all conflict regions from content"""
              pattern = r'(<<<<<<< HEAD\n)(.*?)(=======\n)(.*?)(>>>>>>> .*?\n)'
              conflicts = []
              for match in re.finditer(pattern, content, re.DOTALL):
                  conflicts.append({
                      'full_match': match.group(0),
                      'head_version': match.group(2),
                      'incoming_version': match.group(4),
                      'start': match.start(),
                      'end': match.end()
                  })
              return conflicts

          for filepath in conflicting_files:
              print(f"\n{'='*60}")
              print(f"Processing: {filepath}")
              print('='*60)
              
              # Read the conflicted file content
              with open(filepath, 'r') as f:
                  conflicted_content = f.read()
              
              # Extract conflict regions
              conflicts = extract_conflicts(conflicted_content)
              print(f"Found {len(conflicts)} conflict region(s) in file")
              
              # Resolve each conflict region individually
              resolved_content = conflicted_content
              
              for i, conflict in enumerate(conflicts):
                  print(f"\n  Conflict {i+1}/{len(conflicts)}:")
                  print(f"    HEAD version: {len(conflict['head_version'])} chars")
                  print(f"    Incoming version: {len(conflict['incoming_version'])} chars")
                  
                  # Ask AI to resolve just this conflict
                  prompt = f"""You are resolving ONE git merge conflict in a backport PR.

          **Context:**
          - Backporting to `{base_branch}`
          - This is conflict region {i+1} of {len(conflicts)} in file `{filepath}`

          **HEAD version (what's in the release branch):**
          ```
          {conflict['head_version']}
          ```

          **Incoming version (what the backport is trying to apply):**
          ```
          {conflict['incoming_version']}
          ```

          **Your task:**
          Provide the RESOLVED content for this conflict region only.

          **Rules:**
          1. Return ONLY the resolved content (no markers, no explanations)
          2. If incoming removes code, prefer the removal unless release branch has critical differences
          3. If incoming adds code, include it unless it conflicts with release-specific changes
          4. Keep important comments from the release branch
          5. No markdown blocks, just the raw resolved content

          Return ONLY the resolved content for this section:
          """

                  print(f"    üì§ Sending to AI... (prompt: {len(prompt)} chars)")
                  
                  response = client.messages.create(
                      model="claude-sonnet-4-20250514",
                      max_tokens=2000,
                      messages=[{"role": "user", "content": prompt}]
                  )

                  resolution = response.content[0].text.strip()
                  
                  # Clean up markdown if present
                  if resolution.startswith("```"):
                      lines = resolution.split('\n')
                      resolution = '\n'.join(lines[1:-1] if lines[-1].startswith('```') else lines[1:])
                      resolution = resolution.strip()
                  
                  print(f"    üì• Received: {len(resolution)} chars, {response.usage.input_tokens} in / {response.usage.output_tokens} out tokens")
                  print(f"    Resolution preview: {resolution[:100]}{'...' if len(resolution) > 100 else ''}")
                  
                  # Store the resolution
                  conflict['resolved'] = resolution
              
              # Replace all conflicts with resolutions (work backwards to maintain indices)
              for i in range(len(conflicts) - 1, -1, -1):
                  conflict = conflicts[i]
                  resolved_content = resolved_content[:conflict['start']] + conflict['resolved'] + resolved_content[conflict['end']:]
              
              print(f"\nüìä Result:")
              print(f"   Original file: {len(conflicted_content.split(chr(10)))} lines")
              print(f"   Resolved file: {len(resolved_content.split(chr(10)))} lines")

              # Write the resolved content
              print(f"\nüíæ Writing resolved content to {filepath}")
              with open(filepath, 'w') as f:
                  f.write(resolved_content)
              
              # Stage the resolved file
              subprocess.run(['git', 'add', filepath], check=True)
              
              print(f"\n‚úÖ Resolved: {filepath}")

          print("\n" + "="*60)
          print("All conflicts resolved!")
          print("="*60)
          EOF
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          BASE_BRANCH: ${{ steps.pr.outputs.base_branch }}
          HEAD_BRANCH: ${{ steps.pr.outputs.head_branch }}
          ORIGINAL_PR: ${{ steps.pr.outputs.original_pr }}

      - name: Commit and push resolution
        if: steps.conflicts.outputs.has_conflicts == 'true'
        run: |
          # Complete the merge
          git commit -m "AI-resolved merge conflicts for backport

          Conflicts resolved by AI bot in:
          $(cat conflicting_files.txt | sed 's/^/- /')"
          
          # Push the changes
          git push origin ${{ steps.pr.outputs.head_branch }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update PR
        run: |
          PR_NUMBER=${{ steps.pr.outputs.number }}
          
          if [ "${{ steps.conflicts.outputs.has_conflicts }}" == "true" ]; then
            # Remove conflict labels (ignore errors if they don't exist)
            gh pr edit $PR_NUMBER --remove-label "needs-ai-resolution" || true
            gh pr edit $PR_NUMBER --remove-label "backport-conflict" || true
            # Add resolved label
            gh pr edit $PR_NUMBER --add-label "ai-conflict-resolved"
            
            gh pr comment $PR_NUMBER --body "ü§ñ **AI Conflict Resolution Complete**
            
          The following files had conflicts that were automatically resolved:
          $(cat conflicting_files.txt | sed 's/^/- \`/' | sed 's/$/\`/')
          
          ‚ö†Ô∏è **Please review the resolved conflicts carefully before approving.**
          
          The AI attempted to:
          1. Apply the intended backported changes
          2. Adapt them to the release branch's code structure
          3. Preserve release-branch-specific code where appropriate"
          else
            gh pr comment $PR_NUMBER --body "‚úÖ No conflicts detected - the PR is ready for review!"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Handle resolution failure
        if: failure()
        run: |
          gh pr comment ${{ steps.pr.outputs.number }} --body "‚ùå **AI Conflict Resolution Failed**
          
          The AI bot was unable to automatically resolve the conflicts.
          
          Manual intervention is required. Please:
          1. Check out the branch locally
          2. Resolve conflicts manually
          3. Push the resolution
          
          Or comment \`/resolve-conflicts\` to retry."
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}



